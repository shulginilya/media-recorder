[{"/home/ilya/web_projects/media-recorder/src/index.js":"1","/home/ilya/web_projects/media-recorder/src/MediaRecorderComponent.js":"2","/home/ilya/web_projects/media-recorder/src/libs/Helpers.js":"3"},{"size":264,"mtime":1612252262379,"results":"4","hashOfConfig":"5"},{"size":6638,"mtime":1612295331106,"results":"6","hashOfConfig":"5"},{"size":1741,"mtime":1612257596976,"results":"7","hashOfConfig":"5"},{"filePath":"8","messages":"9","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"10"},"1vpkafn",{"filePath":"11","messages":"12","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"13","usedDeprecatedRules":"10"},{"filePath":"14","messages":"15","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"16","usedDeprecatedRules":"17"},"/home/ilya/web_projects/media-recorder/src/index.js",[],["18","19"],"/home/ilya/web_projects/media-recorder/src/MediaRecorderComponent.js",["20","21"],"import { useEffect, useState, useRef } from 'react';\nimport { getBrowser } from './libs/Helpers';\nimport './style/media_recorder.scss';\n\nconst MediaRecorderComponent = () => {\n    const chunks = [];\n    /**\n     * State\n     */\n    const [isRecording, setRecordingStatus] = useState(false);\n    const [mediaRecorder, setMediaRecorder] = useState({});\n    const [downloadUrl, setDownloadUrl] = useState('');\n    /**\n     * Lifetime cycles (via hook)\n     * Empty array we are passing\n     * Since i want useEffect to be run only once upon mounting\n     */\n    useEffect(() => {\n        initMediaRecorder();\n    }, []);\n    /**\n     * Set up references for the DOM elements\n     */\n    const liveVideoElementRef = useRef(null);\n    const downloadLinkRef = useRef(null);\n    /**\n     * Build configuration object for media stream\n     * Support: only Chrome / Firefox\n     * Due Media Recording API support limitations\n     *\n     * @return Object\n     */\n    const getMediaStreamConfig = () => {\n        let options = {};\n        const browser = getBrowser();\n        if (browser.name === 'Chrome') {\n            options = {\n                audio: true,\n                video: {\n                    mandatory: {\n                        minWidth: 640,\n                        maxWidth: 640,\n                        minHeight: 480,\n                        maxHeight: 480\n                    },\n                    optional: []\n                }\n            };\n        } else if (browser.name === 'Firefox') {\n            options = {\n                audio: true,\n                video: {\n                    width: {\n                        min: 640,\n                        ideal: 640,\n                        max: 640\n                    },\n                    height: {\n                        min: 480,\n                        ideal: 480,\n                        max: 480\n                    }\n                }\n            };\n        }\n        return options;\n    }\n    const mediaStreamConfig = getMediaStreamConfig();\n    /**\n     * Initialize media stream\n     *\n     */\n    const initMediaRecorder = async () => {\n        /*\n            Handling limitations errors\n        */\n        if (!navigator.mediaDevices.getUserMedia || window.MediaRecorder === undefined) {\n            console.log('navigator.mediaDevices.getUserMedia or MediaRecorder not supported on your browser, use the latest version of Firefox or Chrome');\n            return;\n        }\n        /*\n            Initialize media stream\n            And play it by default\n        */\n        const streamObject = await navigator.mediaDevices.getUserMedia(mediaStreamConfig);\n        liveVideoElementRef.current.srcObject = streamObject;\n        liveVideoElementRef.current.play();\n        /*\n            Initialize media recorder object \n        */\n        let containerType = 'video/webm';\n        let mediaRecorderObject = null;\n        if (typeof MediaRecorder.isTypeSupported === 'function') {\n            let options = {\n                mimeType: 'video/mp4'\n            }\n            if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) {\n                options['mimeType'] = 'video/webm;codecs=vp9';\n            } else if (MediaRecorder.isTypeSupported('video/webm;codecs=h264')) {\n                options['mimeType'] = 'video/webm;codecs=h264';\n            } else  if (MediaRecorder.isTypeSupported('video/webm')) {\n                options['mimeType'] = 'video/webm';\n            } else {\n                containerType = \"video/mp4\";\n            }\n            mediaRecorderObject = new MediaRecorder(streamObject, options);\n        } else {\n            mediaRecorderObject = new MediaRecorder(streamObject);\n        }\n        /*\n            Media recorder events listeners\n            Fill up chunks with a data\n            Use to build video for download\n        */\n        mediaRecorderObject.ondataavailable = (e) => {\n            if (e.data && e.data.size > 0) {\n                chunks.push(e.data);\n            }\n        };\n        /*\n            Media recorder events listeners\n            Stop recording even handler\n        */\n        mediaRecorderObject.onstop = () => {\n            /*\n                Build download link\n            */\n\t\t\tconst recording = new Blob(chunks, {\n                type: mediaRecorder.mimeType\n            });\n            const downloadUrl = URL.createObjectURL(recording);\n            /*\n                Build the filename\n            */\n            let fileName = '';\n            const rand =  Math.floor((Math.random() * 10000000));\n\t\t\tswitch(containerType) {\n\t\t\t\tcase \"video/mp4\": {\n                    fileName  = `video_${rand}.mp4`;\n\t\t\t\t\tbreak;\n                }\n\t\t\t\tdefault: {\n                    fileName  = `video_${rand}.webm`;\n                }\n            }\n            /*\n                Assing attributes to the DOM link\n            */\n            downloadLinkRef.current.href = downloadUrl;\n            downloadLinkRef.current.setAttribute('download', fileName);\n            downloadLinkRef.current.setAttribute('name', fileName);\n            setDownloadUrl(downloadUrl);\n\t\t};\n        /*\n            Update state\n        */\n        setMediaRecorder(mediaRecorderObject);\n    }\n    \n    /**\n     * Controls\n     * Start recording\n     */\n    const beginRecord = () => {\n        if (!isRecording) {\n            mediaRecorder.start(1000);\n            setRecordingStatus(true);\n        }\n    }\n    /**\n     * Controls\n     * Stop recording\n     */\n    const stopRecord = () => {\n        if (isRecording) {\n            mediaRecorder.stop();\n            setRecordingStatus(false);\n        }\n    }\n\n    return (\n        <div className=\"media_recorder\">\n            <div className=\"media_recorder__video-element\">\n                <video ref={liveVideoElementRef} controls></video>\n            </div>\n            <div className=\"media_recorder__controls\">\n                <div className=\"media_recorder__controls__left\">\n                    <button className={isRecording ? 'media_recorder__controls__button disabled' : 'media_recorder__controls__button'} disabled={isRecording} onClick={beginRecord}>Start recording</button>\n                    <button className={isRecording ? 'media_recorder__controls__button' : 'media_recorder__controls__button disabled'} disabled={!isRecording} onClick={stopRecord}>Stop recording</button>\n                </div>\n                <a ref={downloadLinkRef} href=\"#\" className={downloadUrl === '' ? 'media_recorder__controls__button disabled' : 'media_recorder__controls__button'}>Download</a>\n            </div>\n        </div>\n    );\n}\n\nexport default MediaRecorderComponent;\n","/home/ilya/web_projects/media-recorder/src/libs/Helpers.js",["22","23"],"const  getBrowser = () => {\n    const ua = navigator.userAgent;\n    let browser = {};\n\n\tconst getFirstMatch = (regex) => {\n\t\tconst match = ua.match(regex);\n\t\treturn (match && match.length > 1 && match[1]) || '';\n\t}\n\n\tconst getSecondMatch = (regex) => {\n\t\tconst match = ua.match(regex);\n\t\treturn (match && match.length > 1 && match[2]) || '';\n\t}\n\n\t// start detecting\n\tif (/opera|opr/i.test(ua)) {\n\t\tbrowser = {\n\t\t\tname: 'Opera',\n\t\t\ttype: 'opera',\n\t\t\tversion: getFirstMatch(/version\\/(\\d+(\\.\\d+)?)/i) || getFirstMatch(/(?:opera|opr)[\\s\\/](\\d+(\\.\\d+)?)/i)\n\t\t}\n\t}  else if (/msie|trident/i.test(ua)) {\n\t\tbrowser = {\n\t\t\tname: 'Internet Explorer',\n\t\t\ttype: 'msie',\n\t\t\tversion: getFirstMatch(/(?:msie |rv:)(\\d+(\\.\\d+)?)/i)\n\t\t}\n\t} else if (/chrome.+? edge/i.test(ua)) {\n\t\tbrowser = {\n\t\t\tname: 'Microsft Edge',\n\t\t\ttype: 'msedge',\n\t\t\tversion: getFirstMatch(/edge\\/(\\d+(\\.\\d+)?)/i)\n\t\t}\n\t} else if (/chrome|crios|crmo/i.test(ua)) {\n\t\tbrowser = {\n\t\t\tname: 'Chrome',\n\t\t\ttype: 'chrome',\n\t\t\tversion: getFirstMatch(/(?:chrome|crios|crmo)\\/(\\d+(\\.\\d+)?)/i)\n\t\t}\n\t} else if (/firefox/i.test(ua)) {\n\t\tbrowser = {\n\t\t\tname: 'Firefox',\n\t\t\ttype: 'firefox',\n\t\t\tversion: getFirstMatch(/(?:firefox)[ \\/](\\d+(\\.\\d+)?)/i)\n\t\t}\n\t} else if (!(/like android/i.test(ua)) && /android/i.test(ua)) {\n\t\tbrowser = {\n\t\t\tname: 'Android',\n\t\t\ttype: 'android',\n\t\t\tversion: getFirstMatch(/version\\/(\\d+(\\.\\d+)?)/i)\n\t\t}\n\t} else if (/safari/i.test(ua)) {\n\t\tbrowser = {\n\t\t\tname: 'Safari',\n\t\t\ttype: 'safari',\n\t\t\tversion: getFirstMatch(/version\\/(\\d+(\\.\\d+)?)/i)\n\t\t}\n\t} else {\n\t\tbrowser = {\n\t\t\tname: getFirstMatch(/^(.*)\\/(.*) /),\n\t\t\tversion: getSecondMatch(/^(.*)\\/(.*) /)\n\t\t}\n\t\tbrowser.type = browser.name.toLowerCase().replace(/\\s/g, '');\n\t}\n\treturn browser;\n}\n\nexport {\n    getBrowser\n};\n",["24","25"],{"ruleId":"26","replacedBy":"27"},{"ruleId":"28","replacedBy":"29"},{"ruleId":"30","severity":1,"message":"31","line":20,"column":8,"nodeType":"32","endLine":20,"endColumn":10,"suggestions":"33"},{"ruleId":"34","severity":1,"message":"35","line":191,"column":17,"nodeType":"36","endLine":191,"endColumn":165},{"ruleId":"37","severity":1,"message":"38","line":20,"column":88,"nodeType":"39","messageId":"40","endLine":20,"endColumn":89,"suggestions":"41"},{"ruleId":"37","severity":1,"message":"38","line":44,"column":41,"nodeType":"39","messageId":"40","endLine":44,"endColumn":42,"suggestions":"42"},{"ruleId":"26","replacedBy":"43"},{"ruleId":"28","replacedBy":"44"},"no-native-reassign",["45"],"no-negated-in-lhs",["46"],"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'initMediaRecorder'. Either include it or remove the dependency array.","ArrayExpression",["47"],"jsx-a11y/anchor-is-valid","The href attribute requires a valid value to be accessible. Provide a valid, navigable address as the href value. If you cannot provide a valid href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","JSXOpeningElement","no-useless-escape","Unnecessary escape character: \\/.","Literal","unnecessaryEscape",["48","49"],["50","51"],["45"],["46"],"no-global-assign","no-unsafe-negation",{"desc":"52","fix":"53"},{"messageId":"54","fix":"55","desc":"56"},{"messageId":"57","fix":"58","desc":"59"},{"messageId":"54","fix":"60","desc":"56"},{"messageId":"57","fix":"61","desc":"59"},"Update the dependencies array to be: [initMediaRecorder]",{"range":"62","text":"63"},"removeEscape",{"range":"64","text":"65"},"Remove the `\\`. This maintains the current functionality.","escapeBackslash",{"range":"66","text":"67"},"Replace the `\\` with `\\\\` to include the actual backslash character.",{"range":"68","text":"65"},{"range":"69","text":"67"},[613,615],"[initMediaRecorder]",[533,534],"",[533,533],"\\",[1172,1173],[1172,1172]]